= Functional test automation

== General best practices
=== Utilize different integration levels
Typical:

* Unit: test for smallest testable unit; not more than one class; no database; all other classes mocked
* (Unit-Integration): closely rated units together; no database; outside scope mocked; often not considered as an extra level, but as part of Unit Tests
* Subsystem (API): fully integrated deployable part of the system; usually with database (can be in memory); API calls not via Java methods, but from the outside, e.g. REST; external systems or system parts are mocked
* System (UI): fully integrated system with backend and frontend, usually database; external systems are mocked

Good practices:

* Unit tests for business-logic and exceptional flows that need mocking
* Adapters, coordinators implicitly in Subsystem/ System tests
TODO: add graphic
* pyramid style

=== Apply FIRST principle
https://dzone.com/articles/first-principles-solid-rules-for-tests

=== Decide what to test before you start coding
Sounds obvious, but reality shows something else.

== Unit- and Unit-Integration testing

* AAA pattern

* High coverage != good tests, but low coverage = missing tests

* Use TDD to improve code and test quality

https://testing.googleblog.com/2014/03/testing-on-toilet-what-makes-good-test.html

== Subsystem- and System-testing (API + UI)
API test in this section means a functional test (step) that uses the API calls to trigger or check functionality of the fully integrated system under test.
This is a difference to unit testing of a method that exposes an endpoint via REST.

Typical Tool: RestAssured
TODO: example

=== Use BDD to develop test scenarios
Typical Tool: Cucumber

==== BDD and bad good practices
https://automationpanda.com/2017/01/30/bdd-101-writing-good-gherkin/

Most important:

* Collaborate with business, dev and test
* Short scenarios (leave out irrelevant data, combine UI steps)
* Do NOT use Generic UI steps

=== Mix API and UI steps
Just because your expected result can only be checked in the UI does not mean your whole test must be executed via UI.
You can use the API to create you preconditions and the perform some step in the UI.
This makes the complete test faster and more reliable.

=== Hide API authentication at a central point

=== Encapsulate UI technology specific logic in page objects

=== Reflect UI components in your test code

=== Add screenshots to the result report

=== Mock external system that are not in your scope
Typical tool: Wiremock


=== Keep references to data in the database at a central place

=== Use test data builders with defaults for complex structures

=== Prevent explicit waiting

Selenium implicit wait

Typical tool: Awaitility

== Consumer Driven Contract testing
Typical tool: PACT

* How to decide about integration level
Unit, Unit Integration vs. Subsystem

* How to apply to asynchronous communication
Helper: Embedded Kafka

* How do pipelines interact -> use Pact Broker

