= Consumer Driven Contract (CDC) Tests

// TODO in general, add links

Typical tool: PACT

In distributed systems, for example with a microservice architecture in which the overall system is distributed across many different subsystems / microservices, the complexity migrates particularly to the integration of these services.
A complete integration test is often expensive and not very practical, since all subsystems / microservices have to be started / maintained.
Additional complexity arises from different versions of the services and their compatibility with one another.
This is where Consumer Driven Contract (CDC) tests come into play.
Starting from the consumer of an interface, they check the compatibility between provider and consumer without both having to run at the same time.
The interface is represented by contracts that both sides commit to.
CDCs can be used for synchronous interfaces such as REST, but also for event-based asynchronous interfaces.
CDCs mainly test the integration between subsystems and their compatibility.
They do not replace functional tests such as unit or (sub)substem tests.

== How to decide about integration level

A central decision in the development of CDCs is the level of integration, i.e. how much is tested on the consumer and provider side.

The recommendation for the consumer is very clear here that at least the validation of the input / event and possibly also the business logic are also tested.
Database connections or other external systems should be mocked.
This ensures that the input/event is at least valid and can be processed.

It is quite similar on the provider side, because databases or other systems should also be mocked there.
The creation of the input / the event should also go through part of the logic here and not be created completely synthetically.

== How to apply to synchronous communication

// TODO (kathrin)

== How to apply to asynchronous communication
Helper: Embedded Kafka

As described at the beginning, asynchronous event-based interfaces can also be tested with CDCs or PACT as a framework.

The following example shows the communication between a cart management system as a provider and the warehouse management system as a consumer with an event that is emitted when the cart is checked out.

The test begins on the consumer side, in our example with the warehouse management system.
First, the contract / PACT is described here by defining which event, with which content and which metadata is expected.
The test then includes the verification and logic on the consumer side with exactly this event.
This ensures that the event defined in the contract can also be processed error-free on the consumer side.
Note that at this point, neither the other system nor an event broker are involved, so the test can be run in complete isolation.

Consumer test::
+
--
[source, java]
@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "CartMgmtSrv", pactVersion = PactSpecVersion.V3)
public class CartCheckedOutConsumerPactTest {
    @Pact(consumer = "WarehouseMgmtSrv")
    public RequestResponsePact createPactForCartCheckedOut(PactDslWithProvider builder) {
        return builder
            .given("CartCheckedOutSimple")
            .expectsToReceive("CartCheckedOut")
            .withContent(createCartCheckedOutJsonBody())
            .withMetadata(createCartCheckedOutHeader())
            .toPact();
    }
    @Test
    @PactTestFor(pactMethod = "createPactForCartCheckedOut", providerType = ProviderType.ASYNCH)
    void testCartCheckedOutSimple(final MessagePact messagePact){
        // given
        final String json = messagePact.getMessages().get(0).contentsAsString();
        // call consumer logic and validation of json
    }
    // ...
}
--

// TODO chris add example how to create the PACT content / metadata from example

After the contract has been created, it must now be ensured on the provider side that the generated events correspond to it.
So whether in our example the correct events are generated when the cart is checked out.
For this purpose, the state is prepared in the form of test data and mocks.

In the actual test on the provider side, the respective service method that generates the respective event is now triggered.
Depending on the technical setup, the next step is to collect the generated event from the event broker and make it available for provider verification.
This test thus ensures that the correct events are generated by the provider assuming the state.
By using embedded Kafka or in-memory Kafka at Quarkus, these tests can also be run completely isolated without additional systems.

Provider test::
+
--
[source, java]
@Provider("CartMgmtSrv")
@Consumer("WarehouseMgmtSrv")
public class CartCheckedOutProviderPactTest {
    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        context.verifyInteraction();
    }
    @BeforeEach
    void before(PactVerificationContext context){
        context.setTarget(new MessageTestTarget());
    }
    @State("CartCheckedOutSimple")
    public void setupCartCheckedOutSimple(){
        // Setup testdata, mocks ...
    }
    @PactVerifyProvider("CartCheckedOut")
    String verifyMessageForCartCheckedOut() {
        // when
        // Trigger service method with testdata and mock configuration from state
        // then
        // Extract output of the service e.g. messages in embedded Kafka
        final byte[] message = // event broker specific logic for determining the body of the message
        final Map<String, Object> headers = // event broker specific logic for determining the header of the message
        return new MessageAndMetadata(message, headers); // this will be used for provider verification
    }
}
--

// TODO chris - check example return type

== Integration of CDCs into CI/CD pipelines

