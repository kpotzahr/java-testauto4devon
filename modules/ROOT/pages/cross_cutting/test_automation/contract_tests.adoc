= Consumer Driven Contract (CDC) Tests

// TODO in general, add links

Typical tool: PACT

In distributed systems, for example with a microservice architecture in which the overall system is distributed across many different subsystems / microservices, the complexity migrates particularly to the integration of these services.
A complete integration test is often expensive and not very practical, since all subsystems / microservices have to be started / maintained.
Additional complexity arises from different versions of the services and their compatibility with one another.
This is where Consumer Driven Contract (CDC) tests come into play.
Starting from the consumer of an interface, they check the compatibility between provider and consumer without both having to run at the same time.
The interface is represented by contracts that both sides commit to.
CDCs can be used for synchronous interfaces such as REST, but also for event-based asynchronous interfaces.
CDCs mainly test the integration between subsystems and their compatibility.
They do not replace functional tests such as unit or (sub)substem tests.

== How to decide about integration level

A central decision in the development of CDCs is the level of integration, i.e. how much is tested on the consumer and provider side.

The recommendation for the consumer is very clear here that at least the validation of the input / event and possibly also the business logic are also tested.
Database connections or other external systems should be mocked.
This ensures that the input/event is at least valid and can be processed.

It is quite similar on the provider side, because databases or other systems should also be mocked there.
The creation of the input / the event should also go through part of the logic here and not be created completely synthetically.

== How to apply to synchronous communication

As an example for this section, we use two microservices in a system for bets on sport tournaments.
The provider offers a REST API for information about scheduled matches (teams, date, stadium, ...).
The consumer needs the teams of the match for a given id.

Consumer services are the initiators of CDC tests. 
They specify the contract they need to work with responses from the provider and implement tests to make sure that they can really handle what comes back.

=== Only specify in the contract what the consumer app really needs
Even if you know that the provider returns more attributes than you need, do not specify them in the contract.
You limit what th provider can easily change unnecessarily.

Example consumer contract with normal response::
+
--
[source, java]
@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "schedule", port = "7080")
@SpringBootTest( properties = {"h2.tcp.enabled=false"})
public class ScheduleConsumerTest {
    @Pact(consumer = "bet", provider = "schedule")
    public RequestResponsePact matchExists(PactDslWithProvider builder) {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        return builder
                .given("match with id 1 exists")
                .uponReceiving("request to return match with id")
                .path("/match/1")
                .method("GET")
                .willRespondWith()
                .status(200)
                .headers(headers)
                .body(new PactDslJsonBody()
                        .numberValue("matchId", 1)
                        .stringMatcher("hometeam", "[A-Z]{3}", "POR")
                        .stringMatcher("foreignteam", "[A-Z]{3}", "GER")
                )
                .toPact();
    }
    ...

--

=== Specify good cases and bad casers using provider states
Even if you focus on data structures that are returned, don't forget that there can be error scenarios that require a contract.
The "given" part in PACT allows specifying different states of the provider.
Each state will produce a different result.
The provider states are what consumer and provider need to discuss and agree on.

Example consumer contract for an error case with other provider state::
+
--
[source, java]
    @Pact(consumer = "bet", provider = "schedule")
    public RequestResponsePact matchDoesNotExist(PactDslWithProvider builder) {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        return builder
                .given("match with id 2 does not exist")
                .uponReceiving("request to return match with id")
                .path("/match/2")
                .method("GET")
                .willRespondWith()
                .status(400)
                .headers(headers)
                .toPact();
    }

--

=== Implement states at provider side without complicated setup like database
The provider only needs to implement the preconditions needed for the provider states. 
The functionality itself is implemented by the provider anyway.
PACT will simply call the API.

Example provider side implementation::
+
--
[source, java]
@ExtendWith(SpringExtension.class)
@Provider("schedule")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT,
        properties = {"server.port=7088"})
public class ScheduleProviderTest {
    @MockBean
    private MatchRepository matchRepository;
    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        context.verifyInteraction();
    }
    @State("match with id 1 exists")
    public void match1Exists() {
        Match match = new Match();
        match.setForeignteam(Participant.BEL);
        match.setHometeam(Participant.GER);
        match.setStarttime(Instant.now());
        match.setId(1L);
        match.setStadium(Stadium.CAMP_NOU);
        Mockito.when(matchRepository.findById(1L)).thenReturn(Optional.of(match));
    }
    @State("match with id 2 does not exist")
    public void match2doesNotExist() {
        Mockito.when(matchRepository.findById(2L)).thenReturn(Optional.empty());
    }
}

--

=== Make sure that the consumer app really understands provider messages
The main focus of CDC tests is to make sure that the provider does not break the contract.
But to be really sure that the communication works, the receiving part needs to be checked as well.

Example contract verification at consumer side::
+
--
[source, java]
@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "spielplan", port = "7080")
@SpringBootTest( properties = {"h2.tcp.enabled=false"})
public class ScheduleConsumerTest {
    @Autowired
    private SpielplanClient spielplanClient;
    // specify pacts
    ...
    // verify pact cosuming
    @Test
    @PactTestFor(pactMethod = "matchExists")
    void verifyCaseMatchExists() {
        Optional<MatchTo> match = spielplanClient.findMatch(1);
        Assertions.assertThat(match.isPresent()).isTrue();
    }
    @Test
    @PactTestFor(pactMethod = "matchDoesNotExist")
    void verifyCaseMatchDoesNorExist() {
        Optional<MatchTo> match = spielplanClient.findMatch(2);
        Assertions.assertThat(match.isPresent()).isFalse();
    }
}

--

== How to apply to asynchronous communication
Helper: Embedded Kafka

As described at the beginning, asynchronous event-based interfaces can also be tested with CDCs or PACT as a framework.

The following example shows the communication between a cart management system as a provider and the warehouse management system as a consumer with an event that is emitted when the cart is checked out.

The test begins on the consumer side, in our example with the warehouse management system.
First, the contract / PACT is described here by defining which event, with which content and which metadata is expected.
The test then includes the verification and logic on the consumer side with exactly this event.
This ensures that the event defined in the contract can also be processed error-free on the consumer side.
Note that at this point, neither the other system nor an event broker are involved, so the test can be run in complete isolation.

Consumer test::
+
--
[source, java]
@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "CartMgmtSrv", pactVersion = PactSpecVersion.V3)
public class CartCheckedOutConsumerPactTest {
    @Pact(consumer = "WarehouseMgmtSrv")
    public RequestResponsePact createPactForCartCheckedOut(PactDslWithProvider builder) {
        return builder
            .given("CartCheckedOutSimple")
            .expectsToReceive("CartCheckedOut")
            .withContent(createCartCheckedOutJsonBody())
            .withMetadata(createCartCheckedOutHeader())
            .toPact();
    }
    @Test
    @PactTestFor(pactMethod = "createPactForCartCheckedOut", providerType = ProviderType.ASYNCH)
    void testCartCheckedOutSimple(final MessagePact messagePact){
        // given
        final String json = messagePact.getMessages().get(0).contentsAsString();
        // call consumer logic and validation of json
    }
    // ...
}
--

// TODO chris add example how to create the PACT content / metadata from example

After the contract has been created, it must now be ensured on the provider side that the generated events correspond to it.
So whether in our example the correct events are generated when the cart is checked out.
For this purpose, the state is prepared in the form of test data and mocks.

In the actual test on the provider side, the respective service method that generates the respective event is now triggered.
Depending on the technical setup, the next step is to collect the generated event from the event broker and make it available for provider verification.
This test thus ensures that the correct events are generated by the provider assuming the state.
By using embedded Kafka or in-memory Kafka at Quarkus, these tests can also be run completely isolated without additional systems.

Provider test::
+
--
[source, java]
@Provider("CartMgmtSrv")
@Consumer("WarehouseMgmtSrv")
public class CartCheckedOutProviderPactTest {
    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        context.verifyInteraction();
    }
    @BeforeEach
    void before(PactVerificationContext context){
        context.setTarget(new MessageTestTarget());
    }
    @State("CartCheckedOutSimple")
    public void setupCartCheckedOutSimple(){
        // Setup testdata, mocks ...
    }
    @PactVerifyProvider("CartCheckedOut")
    String verifyMessageForCartCheckedOut() {
        // when
        // Trigger service method with testdata and mock configuration from state
        // then
        // Extract output of the service e.g. messages in embedded Kafka
        final byte[] message = // event broker specific logic for determining the body of the message
        final Map<String, Object> headers = // event broker specific logic for determining the header of the message
        return new MessageAndMetadata(message, headers); // this will be used for provider verification
    }
}
--

// TODO chris - check example return type

== Integration of CDCs into CI/CD pipelines

